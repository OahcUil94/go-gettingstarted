# 用golang去执行shell命令

crontab本身就是在调度定时任务，把任务分为两类，程序和命令，例如：

- 执行程序：/usr/bin/python stats.py
- 调用命令：cat nginx.log | grep "2018"

## 命令解释器bash

bash有两种工作模式，交互模式：

- 交互模式，用ssh连接到一个服务器上，执行`ls -l`的命令，和终端进行交互就是交互模式，输入命令，回车，给出响应
- 非交互模式，`/bin/bash -c "ls -l"`，非交互模式需要手动的去调用bash，调用bash这样一个程序，指定-c参数，传入一条命令，bash程序就会把这条命令给解释了，并且执行了

所以用golang执行shell命令，其实是用到了bash解释器的非交互模式。

执行命令时，bash会发现调用的命令，会找到命令背后的程序，所以命令也是程序，当执行`/bin/bash -c "命令"`，bash这个解释器会根据`$PATH`环境变量找命令的二进制程序，例如：ls命令就在`/usr/bin/ls`目录下，从命令翻译到程序的绝对路径，是由bash来完成的，bash根据我们配置的环境变量`$PATH`去找到的。

bash也可以执行一个绝对路径的程序，例如：`/bin/bash -c "/usr/bin/ls -l"`，-c参数后面指定的命令本身其实是指定了一个程序。

## 任务执行的底层原理（从操作系统和C语言的层面解答的）

1. 提交任务：准备一条命令cmd，例如：`echo "Hello World"`，将上述命令，通过某种方式，传递给golang程序（例如：http方式传递）
2. 创建管道：golang程序拿到任务，会创建一个管道pipe，pipe是linux操作系统的api，它能够提供类似于管道的效果，数据可以在这里面传输
3. fork子进程：接着golang通过fork系统调用，会创建一个子进程，子进程和golang是两个进程
4. 重定向输出：子进程会把自己的标准输出和标准错误输出，写到pipe里面，也就是子进程向外打印的所有内容都会写入到pipe里面
5. exec执行/bin/bash程序：子进程会执行一个程序，这个程序完全是golang代码逻辑控制的，会命令子进程执行一个/bin/bash程序，这个系统调用叫做exec，这里会把cmd：`echo "Hello World"`传进去，最终就产生了一个子进程执行shell命令的效果，子进程的所有输出会写到pipe里，pipe另一端连接着父进程golang，所以golang能够取到子进程的输出
6. 回收子进程：当子进程shell命令被bash解释器处理完成之后，bash这个程序默认逻辑就是进程退出，进程一旦退出，golang父进程就会感知到这个事情，把子进程占用操作系统的资源回收掉。

整个任务的过程就是上述这样，golang最后从pipe中得到子进程的输出，这是他们最小单元的一个原理，上面提到了一些操作系统的api，都是C语言层面的，golang对他们做了一些封装，下面简单介绍一下C语言的一些api：

- pipe(): 创建了两个文件描述符，文件描述符就相当于打开了文件，pipe()的调用会返回两个文件描述符，fd\[0\]可读，fd\[1\]可写，所以子进程向fd\[1\]写入它的输出，父进程golang就可以从fd\[0\]读到它的输出。
- fork(): 创建子进程，golang创建一个子进程出来，当创建进程的时候，pipe()就会自然的被继承到子进程里，所以子进程可以拿到fd\[1\]，子进程拿到了管道的写入端，就会往管道中写数据。
- dup2(): 重定向子进程stdout/stderr到fd\[1\]，把子进程的标准输出和标准错误输出这两个文件描述符重定向到pipe上
- exec(): 在当前进程内，加载并执行二进制程序，所以子进程接下来通过exec去执行`/bin/bash`这个程序的时候，子进程执行了bash程序，bash程序执行了命令，命令的输出会被写到fd\[1\]里，所以golang就可以从fd\[0\]里读到程序的输出。

用golang去执行shell命令的时候，不会涉及到这些底层细节的，会使用golang里面的Command类去完成这所有的事情，这个类定义在os/exec包中，基于操作系统底层的C语言api实现的，Command类帮我们封装了上述的所有细节。

