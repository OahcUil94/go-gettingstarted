# 任务调度

## 任务调度传统方案介绍

任务调度传统方案就是linux下的crontab，我们使用crontab的时候会遇到几个问题：

1. 配置任务时，需要ssh登录到脚本服务器进行操作，任务可能就是一个脚本，定时执行，一般来说这样是没有什么问题，但是公司规模变大，任务变多之后，不可避免的就需要把任务分散到很多很多服务器上去，这个时候，你要管理你的任务就很麻烦了，需要知道你的任务部署在哪台服务器上，你要连上去。
2. crontab是一个单机的调度，一旦服务器宕机，任务将终止调度，业务就要收到影响，此时就需要人工的介入，迁移到健康的服务器上去。
3. 排查问题低效，有时候你的业务已经挂掉了，然后你还不知道为什么，一顿排查之后发现是你的脚本有问题，脚本出错了，无法方便的查看任务状态与错误的输出，也就是说crontab没有提供一个快速查看脚本失败原因的一些日志。

传统的方案有这么多问题，所以需要做一个分布式的任务调度，分布式任务调度需要解决几类问题：

1. 可视化web后台，方便进行任务管理。
2. 解决服务器宕机带来的影响，所以我们要做分布式架构，集群化调度，不存在单点故障，对调度集群进行随便的加减节点，任务可以永远的调度下去了。
3. 追踪任务执行状态，报错原因，包括脚本的输出，全部捕获起来，然后放到web后台，可视化log查看，可以加上报警功能，就可以随时知道是不是任务有问题了。

国内的分布式任务调度的项目：
当当网：elastic job（java）
点评网：XXL-JOB（java）
个人开发者：light-task-scheduler（LTS）

在做开源项目选型的时候，会遇到的一些问题：
1. 多是企业内部开源出来的，维护精力有限，积累问题较多（这些开源项目一般来自于企业内部开源出来的，他们是先在公司内用，然后开源出来，那么这些开源的维护者他们精力比较有限，还要工作，那么开源社区里的问题解决的比较慢，当你一不小心踩到一个坑的时候，如果你自己没有能力解决，那么你就要等着，或者你根本用不了）
2. 设计文档较少，对社区用户不友好，引入较为谨慎 （这些代码你是否能够做到熟悉，设计文档一般比较少，拿过来用的话，如果你对它的代码和设计不熟，一旦遇到问题，影响了线上业务，能不能马上解决，所以这也是一个引入到公司中必须要考虑的问题）

所以既然开源的项目没有合适的，就需要自研了。

## 从0构建分布式架构

1. master-worker分布式架构: 要做的是一个master-worker分布式架构，也就是集群中有两种角色
2. etcd协调服务: 重点要依托于etcd这一个分布式协调开源项目, etcd相当于java的zookeeper，我们想要做分布式系统，就离不开这种角色
3. CAP理论: 项目应用了CAP理论, 也就是经典的分布式理论
4. Raft协议: 基于Raft协议去实现分布式的日志同步
5. 任务分发: 我们基于etcd去实现任务在集群中的分发
6. 事件广播: 包括强制终止任务, 其实相当于一个事件的广播, 都是基于etcd去做的
7. 分布式锁: 当任务在集群中并发调度的时候, 会有一个分布式锁去防止某一个任务被并发的调度
8. 服务注册与发现: 在web界面上展示出的worker节点的列表, 这是服务注册与发现的实现
9. 多任务调度: 具体golang程序的细节里面, 我们会实现一个worker节点如何同时调度多个任务, 这是一个多任务调度, 会有一个调度模块, 它涉及的就是golang一些细节的代码实现
10. 并发设计: 任务被基于crontab表达式调度到期之后会执行, 这里执行是一个并发执行, 多协程并发执行的一个设计
11. 异步日志: 任务执行完的日志，会通过一个异步的传输
12. mongodb分布式存储: 把日志传输到mongodb, 最终展示在我们的web后台上
13. systemctl服务管理: 在linux环境下去部署一个程序, golang程序会通过systemctl去部署
14. nginx负载均衡: master也是一个集群, 通过nginx的一个负载均衡实现一个高可用

## 架构图介绍

项目包含了master和worker两种角色（相同颜色的部分, 表示他们在做相关的事情）：
管理后台（WebConsole）这是一个前端页面，前端页面会调用后台的`服务接口（apiServer）`，调用接口做任务的管理，任务会保存到`Etcd`中，一旦任务保存到`etcd`中，就会实时的同步到`Worker节点`，worker节点会收到任务，然后进入到`任务调度（Scheduler）`，基于crontab表达式做多个任务的并发调度，当某个任务到期之后，就会交给`任务执行（Executor）`这个模块去并发的执行，执行的过程中，会去上`分布式锁（JobLock）`，任务执行完成之后的日志，会通过`日志转储（logSink）`异步的传输到mongodb里面，然后master节点给web后台提供一个日志的展现。


